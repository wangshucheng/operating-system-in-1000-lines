---
title: RISC-V 基础
---

# RISC-V

就像网页浏览器隐藏了 Windows/macOS/Linux 之间的差异一样，操作系统也隐藏了不同 CPU 之间的差异。换句话说，操作系统是一个控制 CPU 的程序，为应用程序提供了一个抽象层。

在本书中，我选择 RISC-V 作为目标 CPU，原因如下：

- [其规范](https://riscv.org/technical/specifications/) 简单且适合初学者。
- 它是近年来一个热门的 ISA（指令集架构），与 x86 和 Arm 并列。
- 规范中详细记录了设计决策，阅读起来很有趣。

我们将为 **32 位** RISC-V 编写操作系统。当然，你也可以通过一些小的修改来为 64 位 RISC-V 编写。但是，更宽的位宽会使其稍微更复杂，而且更长的地址读起来可能会比较繁琐。

## QEMU virt 机器

计算机由各种设备组成：CPU、内存、网卡、硬盘等等。例如，尽管 iPhone 和树莓派都使用 Arm CPU，但它们自然被视为不同的计算机。

在本书中，我们支持 QEMU `virt` 机器（[文档](https://www.qemu.org/docs/master/system/riscv/virt.html)），原因如下：

- 虽然它在现实世界中并不存在，但它简单且与真实设备非常相似。
- 你可以在 QEMU 上免费模拟它。你不需要购买实体硬件。
- 当你遇到调试问题时，你可以阅读 QEMU 的源代码，或者将调试器附加到 QEMU 进程来调查问题所在。

## RISC-V 汇编基础

RISC-V，或称 RISC-V ISA（指令集架构），定义了 CPU 可以执行的指令。它类似于程序员使用的 API 或编程语言规范。当你编写 C 程序时，编译器会将其翻译成 RISC-V 汇编。不幸的是，要编写操作系统，你需要编写一些汇编代码。但别担心！汇编并不像你想象的那么难。

> [!TIP]
>
> **试试 Compiler Explorer！**
>
> 学习汇编的一个有用工具是 [Compiler Explorer](https://godbolt.org/)，这是一个在线编译器。当你输入 C 代码时，它会显示相应的汇编代码。
>
> 默认情况下，Compiler Explorer 使用 x86-64 CPU 汇编。在右侧窗格中指定 `RISC-V rv32gc clang (trunk)` 以输出 32 位 RISC-V 汇编。
>
> 另外，在编译器选项中指定优化选项如 `-O0`（关闭优化）或 `-O2`（优化级别 2）并查看汇编如何变化也很有趣。

### 汇编语言基础

汇编语言是机器代码的（大部分）直接表示。让我们看一个简单的例子：

```asm
addi a0, a1, 123
```

通常，每行汇编代码对应一条指令。第一列（`addi`）是指令名称，也称为*操作码*。后面的列（`a0, a1, 123`）是*操作数*，即指令的参数。在这个例子中，`addi` 指令将值 `123` 加到寄存器 `a1` 中的值上，并将结果存储在寄存器 `a0` 中。

### 寄存器

寄存器就像 CPU 中的临时变量，它们比内存快得多。CPU 从内存读取数据到寄存器中，在寄存器上进行算术运算，然后将结果写回到内存/寄存器。

以下是 RISC-V 中的一些常见寄存器：

| 寄存器 | ABI 名称（别名） | 描述 |
|---| -------- | ----------- |
| `pc` | `pc`       | 程序计数器（下一条指令的位置） |
| `x0` |`zero`     | 硬连线零（始终读取为零） |
| `x1` |`ra`         | 返回地址 |
| `x2` |`sp`         | 栈指针 |
| `x5` - `x7` | `t0` - `t2` | 临时寄存器 |
| `x8` | `fp`      | 栈帧指针 |
| `x10` - `x11` | `a0` - `a1`  | 函数参数/返回值 |
| `x12` - `x17` | `a2` - `a7`  | 函数参数 |
| `x18` - `x27` | `s0` - `s11` | 跨调用保存的临时寄存器 |
| `x28` - `x31` | `t3` - `t6` | 临时寄存器 |

> [!TIP]
>
> **调用约定：**
>
> 通常，你可以随意使用 CPU 寄存器，但为了与其他软件的互操作性，寄存器的使用方式是有明确定义的 - 这被称为*调用约定*。
>
> 例如，`x10` - `x11` 寄存器用于函数参数和返回值。为了便于人类阅读，在 ABI 中它们被赋予了像 `a0` - `a1` 这样的别名。查看[规范](https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf)了解更多细节。

### 内存访问

寄存器非常快，但数量有限。大多数数据都存储在内存中，程序使用 `lw`（加载字）和 `sw`（存储字）指令从内存读取/写入数据：

```asm
lw a0, (a1)  // 从 a1 中的地址读取一个字（32位）
             // 并将其存储在 a0 中。在 C 语言中，这相当于：a0 = *a1;
```

```asm
sw a0, (a1)  // 将 a0 中的字存储到 a1 中的地址。
             // 在 C 语言中，这相当于：*a1 = a0;
```

你可以将 `(...)` 视为 C 语言中的指针解引用。在这种情况下，`a1` 是指向 32 位宽值的指针。

### 分支指令

分支指令改变程序的控制流。它们用于实现 `if`、`for` 和 `while` 语句。

```asm
    bnez    a0, <label>   // 如果 a0 不为零，跳转到 <label>
    // 如果 a0 为零，继续执行这里

<label>:
    // 如果 a0 不为零，继续执行这里
```

`bnez` 表示"如果不等于零则分支"。其他常见的分支指令包括 `beq`（相等则分支）和 `blt`（小于则分支）。它们类似于 C 语言中的 `goto`，但带有条件。

### 函数调用

`jal`（跳转并链接）和 `ret`（返回）指令用于调用函数和从函数返回：

```asm
    li  a0, 123      // 将 123 加载到 a0 寄存器（函数参数）
    jal ra, <label>  // 跳转到 <label> 并将返回地址
                     // 存储在 ra 寄存器中。

    // 函数调用后，继续执行这里...

// int func(int a) {
//   a += 1;
//   return a;
// }
<label>:
    addi a0, a0, 1    // 将 a0（第一个参数）加 1

    ret               // 返回到存储在 ra 中的地址。
                      // a0 寄存器包含返回值。
```

根据调用约定，函数参数通过 `a0` - `a7` 寄存器传递，返回值存储在 `a0` 寄存器中。

### 栈

栈是一个后进先出（LIFO）的内存空间，用于函数调用和局部变量。它向下增长，栈指针 `sp` 指向栈顶。

要将值保存到栈中，减少栈指针并存储值（即*压栈*操作）：

```asm
    addi sp, sp, -4  // 将栈指针向下移动 4 字节
                     // （即栈分配）。

    sw   a0, (sp)    // 将 a0 存储到栈中
```

要从栈中加载值，加载值并增加栈指针（即*出栈*操作）：

```asm
    lw   a0, (sp)    // 从栈中加载到 a0
    addi sp, sp, 4   // 将栈指针向上移动 4 字节
                     // （即栈释放）。
```

> [!TIP]
>
> 在 C 语言中，栈操作由编译器生成，所以你不需要手动编写它们。

## CPU 模式

CPU 有多种模式，每种模式具有不同的特权。在 RISC-V 中，有三种模式：

| 模式   | 概述                            |
| ------ | ----------------------------------- |
| M 模式 | OpenSBI（即 BIOS）运行的模式。     |
| S 模式 | 内核运行的模式，又称"内核模式"。 |
| U 模式 | 应用程序运行的模式，又称"用户模式"。  |

## 特权指令

在 CPU 指令中，有一些称为特权指令的类型，应用程序（用户模式）无法执行。在本书中，我们使用以下特权指令：

| 操作码和操作数 | 概述                                                                   | 伪代码                       |
| ------------------------ | -------------------------------------------------------------------------- | -------------------------------- |
| `csrr rd, csr`           | 从 CSR 读取                                                              | `rd = csr;`                      |
| `csrw csr, rs`           | 写入 CSR                                                               | `csr = rs;`                      |
| `csrrw rd, csr, rs`      | 同时从 CSR 读取并写入                                         | `tmp = csr; csr = rs; rd = tmp;` |
| `sret`                   | 从陷阱处理程序返回（恢复程序计数器、操作模式等） |                                  |
| `sfence.vma`             | 清除转换后备缓冲器（TLB）                                   |                                  |

**CSR（控制和状态寄存器）**是存储 CPU 设置的寄存器。CSR 的列表可以在 [RISC-V 特权规范](https://riscv.org/specifications/privileged-isa/) 中找到。

> [!TIP]
>
> 一些指令如 `sret` 会执行一些相当复杂的操作。要理解实际发生的情况，阅读 RISC-V 模拟器源代码可能会有帮助。特别是，[rvemu](https://github.com/d0iasm/rvemu) 的编写方式直观且易于理解（例如 [sret 实现](https://github.com/d0iasm/rvemu/blob/f55eb5b376f22a73c0cf2630848c03f8d5c93922/src/cpu.rs#L3357-L3400)）。

## 内联汇编

在接下来的章节中，你会遇到这样的特殊 C 语言语法：

```c
uint32_t value;
__asm__ __volatile__("csrr %0, sepc" : "=r"(value));
```

这是*"内联汇编"*，一种在 C 代码中嵌入汇编的语法。虽然你可以在单独的文件（`.S` 扩展名）中编写汇编，但使用内联汇编通常更好，原因如下：

- 你可以在汇编中使用 C 变量。同时，你也可以将汇编的结果赋值给 C 变量。
- 你可以将寄存器分配留给 C 编译器。也就是说，你不必手动编写在汇编中要修改的寄存器的保存和恢复。

### 如何编写内联汇编

内联汇编按以下格式编写：

```c
__asm__ __volatile__("assembly" : output operands : input operands : clobbered registers);
```

| 部分               | 描述                                                                 |
| ------------------ | --------------------------------------------------------------------------- |
| `__asm__`          | 表示这是内联汇编。                                           |
| `__volatile__`     | 告诉编译器不要优化 `"assembly"` 代码。                          |
| `"assembly"`       | 作为字符串字面量编写的汇编代码。                                   |
| output operands  | 用于存储汇编结果的 C 变量。                           |
| input operands   | 在汇编中使用的 C 表达式（如 `123`、`x`）。             |
| clobbered registers | 在汇编中内容被破坏的寄存器。如果忘记指定，C 编译器将不会保存这些寄存器的内容，可能会导致错误。 |

输出和输入操作数用逗号分隔，每个操作数按 `constraint (C expression)` 格式编写。约束用于指定操作数的类型，通常输出操作数使用 `=r`（寄存器），输入操作数使用 `r`。

在汇编中可以使用 `%0`、`%1`、`%2` 等访问输出和输入操作数，从输出操作数开始按顺序排列。

### 示例

```c
uint32_t value;
__asm__ __volatile__("csrr %0, sepc" : "=r"(value));
```

这使用 `csrr` 指令读取 `sepc` CSR 的值，并将其赋值给 `value` 变量。`%0` 对应于 `value` 变量。

```c
__asm__ __volatile__("csrw sscratch, %0" : : "r"(123));
```

这使用 `csrw` 指令将 `123` 写入 `sscratch` CSR。`%0` 对应于包含 `123` 的寄存器（`r` 约束），实际上会看起来像：

```
li    a0, 123        // 将 123 设置到 a0 寄存器
csrw  sscratch, a0   // 将 a0 寄存器的值写入 sscratch 寄存器
```

虽然在内联汇编中只写了 `csrw` 指令，但编译器会自动插入 `li` 指令以满足 `"r"` 约束（寄存器中的值）。这非常方便！

> [!TIP]
>
> 内联汇编是编译器特定的扩展，不包含在 C 语言规范中。你可以在 [GCC 文档](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html) 中查看详细用法。但是，理解它需要时间，因为约束语法因 CPU 架构而异，并且它有许多复杂的功能。
>
> 对于初学者，我建议搜索实际的例子。例如，[HinaOS](https://github.com/nuta/microkernel-book/blob/52d66bd58cd95424f009e2df8bc1184f6ffd9395/kernel/riscv32/asm.h) 和 [xv6-riscv](https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/riscv.h) 是很好的参考。
